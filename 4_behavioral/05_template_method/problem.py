"""
❌ PROBLEM: Duplikacja szkieletu algorytmu w każdej klasie

Rozwiązanie bez wzorca Template Method:
- Każda klasa kopiuje ten sam szkielet algorytmu
- Zmiana kolejności kroków wymaga zmian we wszystkich klasach
- Brak gwarancji spójności - łatwo zapomnieć o kroku
- Trudno dodać nowy typ dokumentu z tym samym flow
"""


class ReportDocument:
    """
    ❌ PROBLEM: Generator raportów z duplikacją szkieletu

    Zawiera pełny algorytm generowania w jednej klasie
    """

    def __init__(self, title: str):
        self.title = title

    def generate_document(self) -> str:
        """Generuj dokument - DUPLIKACJA SZKIELETU"""
        # ❌ Ten sam szkielet będzie w każdej klasie
        result = ""

        # Krok 1: Header
        result += "=" * 50 + "\n"
        result += f"REPORT: {self.title}\n"
        result += "=" * 50 + "\n\n"

        # Krok 2: Body
        result += "This is the main body of the report.\n"
        result += f"Report details for: {self.title}\n\n"

        # Krok 3: Signature (opcjonalne)
        result += "Generated by: System\n"

        # Krok 4: Footer
        result += "\n" + "-" * 50 + "\n"
        result += "End of Report\n"
        result += "-" * 50

        return result


class EmailDocument:
    """
    ❌ PROBLEM: Generator emaili z IDENTYCZNYM szkieletem

    Kopiuje ten sam algorytm co ReportDocument
    """

    def __init__(self, subject: str):
        self.subject = subject

    def generate_document(self) -> str:
        """Generuj dokument - TA SAMA STRUKTURA!"""
        # ❌ DUPLIKACJA - ten sam szkielet co w ReportDocument
        result = ""

        # Krok 1: Header (inne szczegóły, ten sam krok)
        result += "From: system@example.com\n"
        result += f"Subject: {self.subject}\n"
        result += "=" * 40 + "\n\n"

        # Krok 2: Body (inne szczegóły, ten sam krok)
        result += "Dear User,\n\n"
        result += f"This email is regarding: {self.subject}\n\n"

        # Krok 3: Signature (opcjonalne - tutaj użyte)
        result += "Best regards,\n"
        result += "The Team\n"

        # Krok 4: Footer (inne szczegóły, ten sam krok)
        result += "\n" + "-" * 40 + "\n"
        result += "This is an automated email.\n"
        result += "-" * 40

        return result


# ❌ Przykład użycia - pokazuje problemy
if __name__ == "__main__":
    report = ReportDocument("Q4 Sales")
    email = EmailDocument("Meeting Reminder")

    print(report.generate_document())
    print("\n" + "=" * 60 + "\n")
    print(email.generate_document())

    # ❌ PROBLEMY:
    # 1. Chcemy dodać krok 5 (timestamp)? Musimy zmienić OBU generatorów
    # 2. Chcemy zmienić kolejność (footer przed signature)? Zmiana w 2 miejscach
    # 3. Dodanie trzeciego typu (InvoiceDocument)? Kopiujemy cały szkielet znowu
    # 4. Łatwo zapomnieć o kroku - brak gwarancji spójności


"""
Jakie problemy rozwiązuje Template Method?

1. ❌ Duplikacja szkieletu algorytmu
   - Ten sam flow (header → body → signature → footer) kopiowany wszędzie
   - Każda zmiana wymaga update'u w wielu miejscach
   - Violates DRY (Don't Repeat Yourself)

2. ❌ Brak gwarancji spójności
   - Łatwo zapomnieć o kroku w jednej z klas
   - Trudno zapewnić że wszystkie klasy robią te same kroki w tej samej kolejności
   - Każdy developer może zaimplementować inaczej

3. ❌ Trudna modyfikacja algorytmu
   - Dodanie nowego kroku = zmiana w każdej klasie
   - Zmiana kolejności kroków = zmiana w każdej klasie
   - Wysokie ryzyko błędów

4. ❌ Kod expansion przy dodawaniu typów
   - Każdy nowy typ dokumentu kopiuje cały szkielet
   - Rośnie liczba miejsc do utrzymania
   - Niemożliwe wymuszenie struktury

Jak Template Method to rozwiązuje?
1. ✅ Szkielet w jednym miejscu - w base class
2. ✅ Subklasy implementują tylko szczegóły kroków
3. ✅ Gwarancja spójności - wszyscy używają tego samego flow
4. ✅ Łatwa modyfikacja - zmiana szkieletu w jednym miejscu
5. ✅ Hook methods dla opcjonalnej customizacji
"""
